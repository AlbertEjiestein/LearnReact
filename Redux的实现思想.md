## Redux的实现思想

### `1.为什么要有dispatch`

`dispatch`函数决定了只能通过action来更改state，用于统一状态管理，不统一状态管理的话，谁都可以修改state，一旦数据可以任意改变，**所有共享该状态的操作都是不可预料的**。但是不用组件之间确实需要共享数据，这些组件可能会修改这些共享数据，这里的矛盾就是：**“模块（组件）之间需要共享数据”，和“数据可能被任意修改导致不可预料的结果”之间的矛盾**。

解决办法是：提高修改数据的门槛，从直接修改变成`dispatch(action)`

### `2. 抽离 store 和监控数据变化`

我们只需要 `subscribe` 一次，后面不管如何 `dispatch` 进行修改数据，`renderApp` 函数都会被重新调用，页面就会被重新渲染。这样的订阅模式还有好处就是，以后我们还可以拿同一块数据来渲染别的页面，这时 `dispatch` 导致的变化也会让每个页面都重新渲染

```js
store.subscribe(() => renderApp(store.getState()))
store.subscribe(() => renderApp2(store.getState())) 
store.subscribe(() => renderApp3(store.getState())) 
```

### `3. 性能优化`

目前的一个问题是，修改某一个`state`，则会获取所有的`state`的最新状态，然后重新渲染，即便某些state修改前后没有发生改变，也会重新渲染。如何指定只渲染变化的state？对比新旧state的值，相等则不渲染。

还有一个问题，`changeState`或者`reducer`中是直接对传入的state进行修改的，state是一个对象(引用数据类型)，这会导致新旧state指向的是同一个对象，无论怎么修改，前后state都一样，那这样就是自欺欺人了，对比新旧state的值也就没有意义了。解决办法是：在`reducer`中，禁止直接修改传入的state，而是复制一份state并修改

### `4. 纯函数`

**一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。**

第一个条件比较好理解，第二个条件，关于副作用指的是一个函数执行过程中某些操作修改了外部状态，这些状态的变化在外部可以观察到。具体情况有修改了传入的外部对象属性，调用`DOM API`修改页面，发送`ajax`请求，调用`window.onload`刷新浏览器。**也就是说，除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据。**比如：

```js
const a = 1
const foo = (obj, b) => {
  obj.x = 2
  return obj.x + b
}
const counter = { x: 1 }
foo(counter, 2) // => 4
counter.x // => 2
```

`foo` 函数的执行对外部的 `counter` 产生了影响，它产生了**副作用**，因为它修改了外部传进来的对象，现在它是不纯的。